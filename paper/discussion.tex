We found that the general intuition that large-scale applications are more difficult to get correct generally holds. Large-scale applications accounted for 11.4\% of the applications we tested, but made up 29.0\% of the applications that crashed. Furthmore, all the hangs that we encountered occured when testing the large-scale applications and they tended to crash with more calls then the smaller utilities. These applications gained some robustness by using the GLib libraries, but ultimately the larger code base and greater complexity resulted in more places to miss error checking.

We also noticed that memory allocation functions (malloc, calloc, and realloc) were the most common cause of core dumps, especially in the smaller utilities. This isn't surprising given that an unchecked return value will lead to derefencing a null pointer and therefore a core dump. In any case, our results show that memory 
allocation has a major affect on robustness and must be handled with care.

A secondary goal of our work was to reexamine the results that Miller et al. encountered when fuzzing the return value of malloc family of functions. We included as many utilities they tested as were availible in our own testing suite. In particular, we tested ctags, df, finger, last, man, sdiff, tsort, users, and w. All of these utilities resulted in crashes for Miller et al. under malloc, but we saw crashes in only df, finger, and w. This suggests that a number of utilities have become more robust since 1995.  
