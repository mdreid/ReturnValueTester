\section{GNU Core Utilities crashes}
\subsection{\texttt{du}}
The coreutils program \texttt{du}, which is used to list disk usage, crashed when \texttt{malloc} returned an error. Upon investigation, it was determined to have used a function \texttt{setup\_dir} (listing \ref{lst:fts-cycle.c}) which allocates memory and returns \texttt{true} if it succeeds, and \texttt{false} otherwise.

\begin{lstlisting}[label={lst:fts-cycle.c},firstnumber=47, caption={\texttt{lib/fts-cycle.c}}]
/* Set up the cycle-detection machinery.  */

static bool
setup_dir (FTS *fts)
{
  if (fts->fts_options & (FTS_TIGHT_CYCLE_CHECK | FTS_LOGICAL))
    {
      enum { HT_INITIAL_SIZE = 31 };
      fts->fts_cycle.ht = hash_initialize (HT_INITIAL_SIZE, NULL, AD_hash,
                                           AD_compare, free);
      if (! fts->fts_cycle.ht)
        return false;
    }
  else
    {
      fts->fts_cycle.state = malloc (sizeof *fts->fts_cycle.state);
      if (! fts->fts_cycle.state)
        return false;
      cycle_check_init (fts->fts_cycle.state);
    }

  return true;
}
\end{lstlisting}

The code does not check the return value, producing a segmentation fault on \texttt{setup\_dir}'s failure.
 The fix is given in listing \ref{lst:fts.c}.
\lstset{numbers=left}
\begin{lstlisting}[label={lst:fts.c},firstnumber=986, caption={\texttt{lib/fts.c:986}}]
-	setup_dir(sp);

+	if (!setup_dir(sp)) {
+		return NULL;
+	}
\end{lstlisting}

\newpage

\begin{lstlisting}[label={lst:hostid/malloc},firstnumber=425, caption={\texttt{hostid} crashes when \texttt{malloc} returns an error. The offending code is in the GLibC 2.23 source code, in \texttt{resolv/res\_send.c:453}.}]

    for (ns = 0; ns < statp->nscount; ns++) {
            EXT(statp).nssocks[ns] = -1;
            if (statp->nsaddr_list[ns].sin_family == 0)
                    continue;
            if (EXT(statp).nsaddrs[ns] == NULL)
                    EXT(statp).nsaddrs[ns] =
                        malloc(sizeof (struct sockaddr_in6));
+	        if(EXT(statp).nsaddrs[ns] != NULL) {
+	                EXT(statp).nscount++;
+	        }
            if (EXT(statp).nsaddrs[ns] != NULL)
                    memset (mempcpy(EXT(statp).nsaddrs[ns],
                                    &statp->nsaddr_list[ns],
                                    sizeof (struct sockaddr_in)),
                            '\0',
                            sizeof (struct sockaddr_in6)
                            - sizeof (struct sockaddr_in));
    }
-    EXT(statp).nscount = statp->nscount;
}
\end{lstlisting}