Many commonly used C library functions return some value. In most cases, these values indicate something that is relevant to the  functions operations, such as a file descriptor, number of bytes processed, or a pointer to some data. Additionally, many functions that can fail return some predefined value that indicates that an error occurred during the function's execution. Unfortunately, many programmers have the bad habit of not checking these return values for such error conditions, which can lead to unexpected behaviors. In our work, we implemented a mechanism to intercept system/library calls in order to force an error value to be returned to an application. By analyzing how common Linux applications respond (or didn't) to these errors, we were able to evaluate the robustness of these applications.

We were primarily interested in finding crashes in the applications that we tested. By a crash we mean either an unintentional core dump or a hang that could only be ended by forcing the application to terminate (usually by using by a Ctrl-C command). This is a somewhat narrower definition than what is commonly used, but it allowed us to quantify crashes in an unambiguous way. Furthermore, these two cases represent situations where an application terminated without its consent. We require the core dump to be unintentional because core dumps can occur within a programs control, such as with \texttt{abort} or \texttt{assert}. These are somewhat inelegant ways of handling errors, but it does not represent a crash as we define it. Similarly, nearly all of the applications we tested displayed aberrant output that is likely not the behavior the developers intended, but this is simply our opinion and is not something that can be meaningfully measured. Nevertheless, we do include some of the more interesting non-crash behaviors that we found. ROADMAP

It is most interesting to test for unchecked return values in both Unix utilities and large scale programs. We restricted our tests to open-source projects, so we could attempt to find the source code lines that caused the bug. We group the applications that we test into three categories: GNU core utilities, networking utilities, and large open-source projects.